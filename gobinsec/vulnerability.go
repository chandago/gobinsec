package gobinsec

import (
	"reflect"
	"sort"
)

// Vulnerability for a vulnerability
type Vulnerability struct {
	ID         string               // CVE ID
	References []string             // Reference URL
	Matchs     []VulnerabilityMatch // version matching
	Exposed    bool                 // tells if this vulnerability is exposed
	Ignored    bool                 // tells id this vulnerability is ignored
}

// NewVulnerability builds a vulnerability from NVD call result
func NewVulnerability(CVE CVE) (*Vulnerability, error) {
	vulnerability := Vulnerability{
		ID: CVE.ID,
	}
	for _, reference := range CVE.References {
		vulnerability.References = append(vulnerability.References, reference.URL)
	}
	sort.Slice(vulnerability.References, func(i, j int) bool {
		return vulnerability.References[i] < vulnerability.References[j]
	})
	for _, configuration := range CVE.Configurations {
		for _, node := range configuration.Nodes {
			for _, match := range node.Match {
				if match.Vulnerable {
					vm, err := NewVulnerabilityMatch(match)
					if err != nil {
						return nil, err
					}
					if !vm.InList(vulnerability.Matchs) {
						vulnerability.Matchs = append(vulnerability.Matchs, *vm)
					}
				}
			}
		}
	}
	vulnerability.Ignored = config.IgnoreVulnerability(vulnerability.ID)
	return &vulnerability, nil
}

// IsExposed tells if given version matchs vulnerability
func (v *Vulnerability) IsExposed(version Version) bool {
	for _, match := range v.Matchs {
		if match.Match(version) {
			v.Exposed = true
			return true
		}
	}
	return false
}

// VulnerabilityMatch are version constraints for vulnerability
type VulnerabilityMatch struct {
	VersionStartExcluding Version
	VersionStartIncluding Version
	VersionEndExcluding   Version
	VersionEndIncluding   Version
}

// NewVulnerabilityMatch return a version match
func NewVulnerabilityMatch(m Match) (*VulnerabilityMatch, error) {
	var vm VulnerabilityMatch
	if m.VersionStartExcluding != "" {
		vm.VersionStartExcluding = NewVersion(m.VersionStartExcluding)
	}
	if m.VersionStartIncluding != "" {
		vm.VersionStartIncluding = NewVersion(m.VersionStartIncluding)
	}
	if m.VersionEndExcluding != "" {
		vm.VersionEndExcluding = NewVersion(m.VersionEndExcluding)
	}
	if m.VersionEndIncluding != "" {
		vm.VersionEndIncluding = NewVersion(m.VersionEndIncluding)
	}
	return &vm, nil
}

// Match tells if given version matches (so that it is affected by vulnerability)
func (m *VulnerabilityMatch) Match(v Version) bool {
	if m.VersionStartExcluding == nil &&
		m.VersionStartIncluding == nil &&
		m.VersionEndExcluding == nil &&
		m.VersionEndIncluding == nil {
		return config.Strict
	}
	if m.VersionStartExcluding != nil {
		r, err := m.VersionStartExcluding.Compare(v)
		if err != nil {
			return true
		}
		if r >= 0 {
			return false
		}
	}
	if m.VersionStartIncluding != nil {
		r, err := m.VersionStartIncluding.Compare(v)
		if err != nil {
			return true
		}
		if r > 0 {
			return false
		}
	}
	if m.VersionEndExcluding != nil {
		r, err := m.VersionEndExcluding.Compare(v)
		if err != nil {
			return true
		}
		if r <= 0 {
			return false
		}
	}
	if m.VersionEndIncluding != nil {
		r, err := m.VersionEndIncluding.Compare(v)
		if err != nil {
			return true
		}
		if r < 0 {
			return false
		}
	}
	return true
}

// InList tells if match in given list
func (m *VulnerabilityMatch) InList(matchs []VulnerabilityMatch) bool {
	for _, match := range matchs {
		if m.Equal(match) {
			return true
		}
	}
	return false
}

// Equal tells if matchs equal
func (m *VulnerabilityMatch) Equal(o VulnerabilityMatch) bool {
	return reflect.DeepEqual(*m, o)
}
